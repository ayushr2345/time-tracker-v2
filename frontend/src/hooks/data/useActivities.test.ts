/**
 * @fileoverview Unit tests for the useActivities hook.
 * This suite verifies the core CRUD operations for activities, ensuring state
 * is correctly updated on success and that proper UI feedback (toast notifications)
 * is provided for both successful actions and specific HTTP error states.
 */

import { renderHook, act } from "@testing-library/react";
import { vi, describe, it, expect, beforeEach, afterEach } from "vitest";
import { AxiosError } from "axios";
import { HTTP_STATUS } from "@time-tracker/shared";
import { useActivities } from "./useActivities";
import { activityService } from "../../services";
import { toast } from "react-toastify";
import { MOCK_ACTIVITIES, MOCK_LOGS } from "../../test/mock";

// --- 1. Mocks ---

/**
 * Mocks the activity data service.
 * Intercepts all backend API calls to ensure tests remain isolated, fast,
 * and deterministic without requiring an actual server.
 */
vi.mock("../../services", () => ({
  activityService: {
    getAllActivities: vi.fn(),
    createActivity: vi.fn(),
    deleteActivity: vi.fn(),
    updateActivity: vi.fn(),
  },
}));

/**
 * Mocks the react-toastify library.
 * Used to verify that success and error notifications are correctly triggered
 * during various API response scenarios.
 */
vi.mock("react-toastify", () => ({
  toast: {
    success: vi.fn(),
    error: vi.fn(),
  },
}));

/**
 * Mocks the global console object.
 * Silences expected error logs generated by the hook during failure tests
 * to keep the test terminal output clean.
 */
const consoleSpy = vi.spyOn(console, "log").mockImplementation(() => {});

// --- 2. Data Hydration ---

/**
 * Simulates the backend aggregation query.
 * The hook expects activities to be returned with a `logCount` property.
 * This dynamically calculates the logCount from the static mock data to ensure
 * tests reflect a production-accurate data structure.
 */
const hydratedMockActivities = MOCK_ACTIVITIES.map((activity) => ({
  ...activity,
  logCount: MOCK_LOGS.filter((log) => log.activityId === activity._id).length,
}));

// --- 3. Helpers ---

/**
 * Helper function to generate simulated Axios errors.
 * @param status - The HTTP status code to simulate (e.g., 400, 404, 409).
 * @param message - Optional server error message to inject into the response data.
 * @returns A fully constructed AxiosError object.
 */
const createAxiosError = (status: number, message?: string) => {
  const error = new AxiosError(message || "Axios Error");
  error.response = {
    status,
    data: message ? { message } : undefined,
  } as any;
  return error;
};

/**
 * Performance optimization helper for hook initialization.
 * Because fetchActivities is called immediately on mount, using a standard
 * `waitFor` introduces unnecessary polling delays. This helper mounts the hook
 * and simply awaits the next event loop tick, drastically reducing test execution time.
 * @returns The rendered hook result.
 */
const setupHook = async () => {
  const rendered = renderHook(() => useActivities());

  await act(async () => {
    await Promise.resolve();
  });

  return rendered;
};

describe("useActivities Hook", () => {
  /**
   * Test Setup:
   * 1. Clears all mocks to guarantee isolation between tests.
   * 2. Sets a default successful mock response for `getAllActivities` since
   * almost every test requires the hook to mount and fetch initial data successfully.
   */
  beforeEach(() => {
    vi.clearAllMocks();
    vi.mocked(activityService.getAllActivities).mockResolvedValue(
      hydratedMockActivities,
    );
  });

  /**
   * Test Teardown:
   * Clears the console spy to prevent side effects on other test suites.
   */
  afterEach(() => {
    consoleSpy.mockClear();
  });

  /**
   * @group Fetching
   * Verifies the initial data load behavior and associated loading states.
   */
  describe("fetchActivities", () => {
    it("should fetch activities on mount and set loading state (Success)", async () => {
      // Manual render is used here instead of setupHook() to explicitly capture
      // the `true` -> `false` transition of the loading state.
      const { result } = renderHook(() => useActivities());

      expect(result.current.loading).toBe(true);

      await act(async () => {
        await Promise.resolve();
      });

      expect(result.current.loading).toBe(false);
      expect(result.current.activities).toEqual(hydratedMockActivities);
      expect(activityService.getAllActivities).toHaveBeenCalledTimes(1);
    });

    it("should handle fetch error", async () => {
      vi.mocked(activityService.getAllActivities).mockRejectedValueOnce(
        new Error("Network Error"),
      );

      const { result } = renderHook(() => useActivities());

      await act(async () => {
        await Promise.resolve();
      });

      expect(toast.error).toHaveBeenCalledWith("Failed to fetch activities");
      expect(result.current.activities).toEqual([]);
    });
  });

  /**
   * @group Creation
   * Verifies the addition of new activities, handling of duplicates (409),
   * and invalid payloads (400).
   */
  describe("addActivity", () => {
    it("should handle success and append with logCount 0", async () => {
      const newActivityPayload = { name: "Meditation", color: "#FFFFFF" };
      const savedActivity = {
        _id: "6",
        ...newActivityPayload,
        createdAt: new Date(),
        updatedAt: new Date(),
      };

      vi.mocked(activityService.createActivity).mockResolvedValueOnce(
        savedActivity as any,
      );

      const { result } = await setupHook();

      let success;
      await act(async () => {
        success = await result.current.addActivity(newActivityPayload);
      });

      expect(success).toBe(true);
      expect(
        result.current.activities[result.current.activities.length - 1],
      ).toEqual({
        ...savedActivity,
        logCount: 0,
      });
      expect(toast.success).toHaveBeenCalledWith(
        'Activity "Meditation" created!',
      );
    });

    it("should handle HTTP 400 Bad Request error", async () => {
      vi.mocked(activityService.createActivity).mockRejectedValueOnce(
        createAxiosError(HTTP_STATUS.BAD_REQUEST),
      );
      const { result } = await setupHook();

      const success = await act(async () =>
        result.current.addActivity({ name: "", color: "" }),
      );

      expect(success).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "Invalid activity data provided.",
      );
    });

    it("should handle HTTP 409 Conflict error", async () => {
      vi.mocked(activityService.createActivity).mockRejectedValueOnce(
        createAxiosError(HTTP_STATUS.CONFLICT),
      );
      const { result } = await setupHook();

      const success = await act(async () =>
        result.current.addActivity({ name: "Coding", color: "#000" }),
      );

      expect(success).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "An activity with this name already exists.",
      );
    });

    it("should handle other Axios errors with backend message", async () => {
      vi.mocked(activityService.createActivity).mockRejectedValueOnce(
        createAxiosError(403, "Limit reached"),
      );
      const { result } = await setupHook();

      const success = await act(async () =>
        result.current.addActivity({ name: "Test", color: "#000" }),
      );

      expect(success).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "Failed to create activity: Limit reached",
      );
    });

    it("should handle generic Javascript errors", async () => {
      vi.mocked(activityService.createActivity).mockRejectedValueOnce(
        new Error("Unknown Failure"),
      );
      const { result } = await setupHook();

      const success = await act(async () =>
        result.current.addActivity({ name: "Test", color: "#000" }),
      );

      expect(success).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "Failed to create activity: Error: Unknown Failure",
      );
    });
  });

  /**
   * @group Deletion
   * Verifies the removal of activities from local state and handles
   * missing resource errors (404) or server crashes (500).
   */
  describe("deleteActivity", () => {
    const idToDelete = MOCK_ACTIVITIES[0]._id; // "1"

    it("should handle success and remove item from state", async () => {
      vi.mocked(activityService.deleteActivity).mockResolvedValueOnce(
        hydratedMockActivities[0] as any,
      );
      const { result } = await setupHook();

      let success;
      await act(async () => {
        success = await result.current.deleteActivity(idToDelete);
      });

      expect(success).toBe(true);
      expect(result.current.activities).toHaveLength(
        hydratedMockActivities.length - 1,
      );
      expect(
        result.current.activities.find((a) => a._id === idToDelete),
      ).toBeUndefined();
      expect(toast.success).toHaveBeenCalledWith(
        "Activity deleted successfully.",
      );
    });

    it("should handle HTTP 404 Not Found error", async () => {
      vi.mocked(activityService.deleteActivity).mockRejectedValueOnce(
        createAxiosError(HTTP_STATUS.NOT_FOUND),
      );
      const { result } = await setupHook();

      const success = await act(async () =>
        result.current.deleteActivity(idToDelete),
      );

      expect(success).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "Activity not found or already deleted.",
      );
    });

    it("should handle HTTP 500 Server error", async () => {
      vi.mocked(activityService.deleteActivity).mockRejectedValueOnce(
        createAxiosError(HTTP_STATUS.SERVER_ERROR),
      );
      const { result } = await setupHook();

      const success = await act(async () =>
        result.current.deleteActivity(idToDelete),
      );

      expect(success).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "Error deleting activity on server.",
      );
    });

    it("should handle generic Javascript errors", async () => {
      vi.mocked(activityService.deleteActivity).mockRejectedValueOnce(
        new Error("Network disconnect"),
      );
      const { result } = await setupHook();

      const success = await act(async () =>
        result.current.deleteActivity(idToDelete),
      );

      expect(success).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "Failed to delete activity: Error: Network disconnect",
      );
    });
  });

  /**
   * @group Updating
   * Verifies modification of existing activities and ensures side-effect
   * data (like logCount) is preserved during the state update.
   */
  describe("updateActivity", () => {
    const idToUpdate = MOCK_ACTIVITIES[0]._id; // "1"
    const updatedPayload = { name: "Deep Work Coding", color: "#111111" };
    const updatedResponse = { ...MOCK_ACTIVITIES[0], ...updatedPayload };

    it("should handle success and preserve existing logCount", async () => {
      vi.mocked(activityService.updateActivity).mockResolvedValueOnce(
        updatedResponse as any,
      );
      const { result } = await setupHook();

      let success;
      await act(async () => {
        success = await result.current.updateActivity(
          idToUpdate,
          updatedPayload,
        );
      });

      expect(success).toBe(true);
      const updatedActivity = result.current.activities.find(
        (a) => a._id === idToUpdate,
      );
      expect(updatedActivity?.name).toBe("Deep Work Coding");

      const originalLogCount = hydratedMockActivities.find(
        (a) => a._id === idToUpdate,
      )?.logCount;
      expect(updatedActivity?.logCount).toBe(originalLogCount);
      expect(toast.success).toHaveBeenCalledWith(
        "Activity updated successfully.",
      );
    });

    it("should handle HTTP 404 Not Found error", async () => {
      vi.mocked(activityService.updateActivity).mockRejectedValueOnce(
        createAxiosError(HTTP_STATUS.NOT_FOUND),
      );
      const { result } = await setupHook();

      const success = await act(async () =>
        result.current.updateActivity(idToUpdate, updatedPayload),
      );

      expect(success).toBe(false);
      expect(toast.error).toHaveBeenCalledWith("Activity not found.");
    });

    it("should handle HTTP 500 Server error", async () => {
      vi.mocked(activityService.updateActivity).mockRejectedValueOnce(
        createAxiosError(HTTP_STATUS.SERVER_ERROR),
      );
      const { result } = await setupHook();

      const success = await act(async () =>
        result.current.updateActivity(idToUpdate, updatedPayload),
      );

      expect(success).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "Error updating activity on server.",
      );
    });

    it("should handle generic Javascript errors", async () => {
      vi.mocked(activityService.updateActivity).mockRejectedValueOnce(
        new Error("Crashed"),
      );
      const { result } = await setupHook();

      const success = await act(async () =>
        result.current.updateActivity(idToUpdate, updatedPayload),
      );

      expect(success).toBe(false);
      expect(toast.error).toHaveBeenCalledWith(
        "Failed to update activity: Error: Crashed",
      );
    });
  });
});
